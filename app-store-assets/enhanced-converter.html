<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced SVG to PNG Converter - App Store Assets</title>
    <style>
        body {
            font-family: 'Inter', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            color: white;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .reload-btn {
            background: linear-gradient(135deg, #FF6B6B, #FF5252);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .reload-btn:hover {
            transform: translateY(-2px) rotate(180deg);
            box-shadow: 0 6px 16px rgba(255, 107, 107, 0.4);
        }
        .reload-btn:active {
            transform: translateY(0) rotate(360deg);
        }
        .reload-btn .reload-text {
            transition: opacity 0.3s ease;
        }
        .reload-btn:hover .reload-text {
            opacity: 0.8;
        }
        .dynamic-icon {
            transition: all 0.5s ease;
            animation: iconFadeIn 0.8s ease-out;
        }
        .dynamic-icon.changing {
            animation: iconRotate 0.6s ease-in-out;
        }
        @keyframes iconFadeIn {
            from {
                opacity: 0;
                transform: scale(0.8) rotate(-10deg);
            }
            to {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
        }
        @keyframes iconRotate {
            0% { transform: scale(1) rotate(0deg); opacity: 1; }
            50% { transform: scale(0.8) rotate(180deg); opacity: 0.5; }
            100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }
        @keyframes reloadPulse {
            0%, 100% { box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3); }
            50% { box-shadow: 0 4px 20px rgba(255, 107, 107, 0.5); }
        }
        .reload-btn {
            animation: reloadPulse 3s ease-in-out infinite;
        }
        .icon-info {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 5px;
            text-align: center;
            font-style: italic;
        }
        .asset-group {
            margin: 30px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .asset-title {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #f8fafc;
        }
        .preview-container {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .preview {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            min-width: 120px;
        }
        .preview img {
            display: block;
            max-width: 100%;
            height: auto;
        }
        .controls {
            flex: 1;
            min-width: 300px;
        }
        .btn {
            background: linear-gradient(135deg, #4A90E2, #357ABD);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            margin: 5px 5px 5px 0;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        .fallback-btn {
            background: linear-gradient(135deg, #50C878, #45B068);
        }
        .debug-btn {
            background: linear-gradient(135deg, #FFD93D, #FFC107);
            color: #333;
        }
        .status-message {
            margin: 10px 0;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
        }
        .status-success {
            background: rgba(108, 207, 127, 0.2);
            border: 1px solid rgba(108, 207, 127, 0.5);
            color: #6BCF7F;
        }
        .status-error {
            background: rgba(255, 71, 87, 0.2);
            border: 1px solid rgba(255, 71, 87, 0.5);
            color: #FF4757;
        }
        .status-info {
            background: rgba(74, 144, 226, 0.2);
            border: 1px solid rgba(74, 144, 226, 0.5);
            color: #4A90E2;
        }
        .debug-info {
            background: rgba(255, 217, 61, 0.2);
            border: 1px solid rgba(255, 217, 61, 0.5);
            color: #FFD93D;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        }
        .instructions {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 30px;
            border-left: 4px solid #4A90E2;
        }
        canvas {
            display: none;
        }
        .quality-selector {
            margin: 10px 0;
        }
        .quality-selector select, .custom-input input, .format-selector select {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px;
            border-radius: 4px;
            margin: 5px;
            min-width: 80px;
        }
        .custom-input input {
            width: 80px;
            text-align: center;
        }
        .custom-input input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        .format-selector {
            margin: 10px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        .format-option {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .format-option input[type="radio"] {
            margin: 0;
        }
        .preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .preview-modal-content {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 30px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            position: relative;
        }
        .preview-modal img {
            max-width: 100%;
            max-height: 70vh;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: white;
        }
        .close-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
        }
        .batch-controls {
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .batch-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #f8fafc;
        }
        .batch-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        .batch-option {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        .batch-option input[type="checkbox"] {
            margin: 0;
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4A90E2, #50C878);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-controls">
            <div>
                <h1 style="margin: 0;">üé® Enhanced App Store Assets Converter</h1>
                <p style="text-align: center; font-size: 1.1em; opacity: 0.9; margin: 10px 0 0 0;">
                    Convert SVG assets to PNG format with debugging and fallback support
                </p>
                <p id="currentStyleIndicator" style="text-align: center; font-size: 0.9em; opacity: 0.7; margin: 5px 0 0 0;">
                    Current Style: Modern
                </p>
                <div style="text-align: center; margin: 10px 0;">
                    <a href="automated-image-generator.html" class="btn" style="text-decoration: none; display: inline-block;">
                        üöÄ Try New: Automated Image Generator
                    </a>
                </div>
            </div>
            <button class="reload-btn" onclick="reloadConverter()" title="Refresh converter and rotate to new icon style (Ctrl+R)">
                <span id="reloadIcon">üîÑ</span>
                <span class="reload-text">Refresh Icons</span>
            </button>
        </div>
        
        <div class="asset-group">
            <div class="asset-title">üì± App Icon - 512x512 (High Resolution)</div>
            <div class="preview-container">
                <div class="preview">
                    <img id="icon512Preview" class="dynamic-icon" width="100" height="100" alt="512x512 Icon Preview">
                    <div class="icon-info" id="icon512Info">Dynamic Icon</div>
                </div>
                <div class="controls">
                    <p>High-resolution app icon for app store listings and large displays</p>

                    <div class="custom-input">
                        Custom Size:
                        <input type="number" id="customWidth512" placeholder="512" min="16" max="2048" value="512">
                        √ó
                        <input type="number" id="customHeight512" placeholder="512" min="16" max="2048" value="512">
                        px
                    </div>

                    <div class="quality-selector">
                        Quality: <select id="quality512">
                            <option value="1.0">High (1.0)</option>
                            <option value="0.9">Medium (0.9)</option>
                            <option value="0.8">Low (0.8)</option>
                        </select>
                    </div>

                    <div class="format-selector">
                        <div class="format-option">
                            <input type="radio" id="png512" name="format512" value="png" checked>
                            <label for="png512">PNG</label>
                        </div>
                        <div class="format-option">
                            <input type="radio" id="jpg512" name="format512" value="jpeg">
                            <label for="jpg512">JPEG</label>
                        </div>
                        <div class="format-option">
                            <input type="radio" id="webp512" name="format512" value="webp">
                            <label for="webp512">WebP</label>
                        </div>
                        <div class="format-option">
                            <input type="radio" id="ico512" name="format512" value="ico">
                            <label for="ico512">ICO</label>
                        </div>
                    </div>

                    <div>
                        <button class="btn" onclick="previewAndConvert('app-icon-512x512.svg', 'icon', '512')">
                            üëÅÔ∏è Preview & Convert
                        </button>
                        <button class="btn fallback-btn" onclick="generateCustomFallback('icon', '512')">
                            üé≤ Generate Fallback
                        </button>
                        <button class="btn debug-btn" onclick="debugConversion('app-icon-512x512.svg', 'debug512')">
                            üîç Debug
                        </button>
                    </div>

                    <div class="batch-controls">
                        <div class="batch-title">üì¶ Batch Export</div>
                        <div class="batch-options">
                            <div class="batch-option">
                                <input type="checkbox" id="batch512png" checked>
                                <label for="batch512png">PNG 512x512</label>
                            </div>
                            <div class="batch-option">
                                <input type="checkbox" id="batch512jpg">
                                <label for="batch512jpg">JPEG 512x512</label>
                            </div>
                            <div class="batch-option">
                                <input type="checkbox" id="batch512webp">
                                <label for="batch512webp">WebP 512x512</label>
                            </div>
                            <div class="batch-option">
                                <input type="checkbox" id="batch256png">
                                <label for="batch256png">PNG 256x256</label>
                            </div>
                        </div>
                        <button class="btn" onclick="batchExport('app-icon-512x512.svg', 'icon', '512')">
                            üì¶ Batch Export Selected
                        </button>
                        <div class="progress-bar" id="progress512" style="display: none;">
                            <div class="progress-fill" id="progressFill512"></div>
                        </div>
                    </div>

                    <div id="status512" class="status-message" style="display: none;"></div>
                    <div id="debug512" class="status-message debug-info" style="display: none;"></div>
                </div>
            </div>
        </div>

        <div class="asset-group">
            <div class="asset-title">üì± App Icon - 114x114 (Standard)</div>
            <div class="preview-container">
                <div class="preview">
                    <img id="icon114Preview" class="dynamic-icon" width="114" height="114" alt="114x114 Icon Preview">
                    <div class="icon-info" id="icon114Info">Dynamic Icon</div>
                </div>
                <div class="controls">
                    <p>Standard app icon for iOS and other platforms</p>

                    <div class="custom-input">
                        Custom Size:
                        <input type="number" id="customWidth114" placeholder="114" min="16" max="2048" value="114">
                        √ó
                        <input type="number" id="customHeight114" placeholder="114" min="16" max="2048" value="114">
                        px
                    </div>

                    <div class="quality-selector">
                        Quality: <select id="quality114">
                            <option value="1.0">High (1.0)</option>
                            <option value="0.9">Medium (0.9)</option>
                            <option value="0.8">Low (0.8)</option>
                        </select>
                    </div>

                    <div class="format-selector">
                        <div class="format-option">
                            <input type="radio" id="png114" name="format114" value="png" checked>
                            <label for="png114">PNG</label>
                        </div>
                        <div class="format-option">
                            <input type="radio" id="jpg114" name="format114" value="jpeg">
                            <label for="jpg114">JPEG</label>
                        </div>
                        <div class="format-option">
                            <input type="radio" id="webp114" name="format114" value="webp">
                            <label for="webp114">WebP</label>
                        </div>
                        <div class="format-option">
                            <input type="radio" id="ico114" name="format114" value="ico">
                            <label for="ico114">ICO</label>
                        </div>
                    </div>

                    <div>
                        <button class="btn" onclick="previewAndConvert('app-icon-114x114.svg', 'icon', '114')">
                            üëÅÔ∏è Preview & Convert
                        </button>
                        <button class="btn fallback-btn" onclick="generateCustomFallback('icon', '114')">
                            üé≤ Generate Fallback
                        </button>
                        <button class="btn debug-btn" onclick="debugConversion('app-icon-114x114.svg', 'debug114')">
                            üîç Debug
                        </button>
                    </div>

                    <div class="batch-controls">
                        <div class="batch-title">üì¶ Batch Export</div>
                        <div class="batch-options">
                            <div class="batch-option">
                                <input type="checkbox" id="batch114png" checked>
                                <label for="batch114png">PNG 114x114</label>
                            </div>
                            <div class="batch-option">
                                <input type="checkbox" id="batch114jpg">
                                <label for="batch114jpg">JPEG 114x114</label>
                            </div>
                            <div class="batch-option">
                                <input type="checkbox" id="batch114webp">
                                <label for="batch114webp">WebP 114x114</label>
                            </div>
                            <div class="batch-option">
                                <input type="checkbox" id="batch114ico">
                                <label for="batch114ico">ICO 114x114</label>
                            </div>
                        </div>
                        <button class="btn" onclick="batchExport('app-icon-114x114.svg', 'icon', '114')">
                            üì¶ Batch Export Selected
                        </button>
                        <div class="progress-bar" id="progress114" style="display: none;">
                            <div class="progress-fill" id="progressFill114"></div>
                        </div>
                    </div>

                    <div id="status114" class="status-message" style="display: none;"></div>
                    <div id="debug114" class="status-message debug-info" style="display: none;"></div>
                </div>
            </div>
        </div>

        <div class="asset-group">
            <div class="asset-title">üñºÔ∏è Feature Graphic - 1280x800 (Banner) - ENHANCED</div>
            <div class="preview-container">
                <div class="preview">
                    <img id="featurePreview" class="dynamic-icon" width="320" height="200" alt="Feature Graphic Preview">
                    <div class="icon-info" id="featureInfo">Dynamic Banner</div>
                </div>
                <div class="controls">
                    <p>Promotional banner image for app store feature sections</p>

                    <div class="custom-input">
                        Custom Size:
                        <input type="number" id="customWidthFeature" placeholder="1280" min="100" max="4096" value="1280">
                        √ó
                        <input type="number" id="customHeightFeature" placeholder="800" min="100" max="4096" value="800">
                        px
                    </div>

                    <div class="quality-selector">
                        Quality: <select id="qualityFeature">
                            <option value="1.0">High (1.0)</option>
                            <option value="0.9" selected>Medium (0.9)</option>
                            <option value="0.8">Low (0.8)</option>
                        </select>
                    </div>

                    <div class="format-selector">
                        <div class="format-option">
                            <input type="radio" id="pngFeature" name="formatFeature" value="png" checked>
                            <label for="pngFeature">PNG</label>
                        </div>
                        <div class="format-option">
                            <input type="radio" id="jpgFeature" name="formatFeature" value="jpeg">
                            <label for="jpgFeature">JPEG</label>
                        </div>
                        <div class="format-option">
                            <input type="radio" id="webpFeature" name="formatFeature" value="webp">
                            <label for="webpFeature">WebP</label>
                        </div>
                        <div class="format-option">
                            <input type="radio" id="svgFeature" name="formatFeature" value="svg">
                            <label for="svgFeature">SVG</label>
                        </div>
                    </div>

                    <div>
                        <button class="btn" onclick="previewAndConvert('feature-graphic-1280x800.svg', 'banner', 'Feature')">
                            üëÅÔ∏è Preview & Convert
                        </button>
                        <button class="btn fallback-btn" onclick="generateCustomFallback('banner', 'Feature')">
                            üé≤ Generate Fallback
                        </button>
                        <button class="btn debug-btn" onclick="debugConversion('feature-graphic-1280x800.svg', 'debugFeature')">
                            üîç Debug Feature Graphic
                        </button>
                    </div>

                    <div class="batch-controls">
                        <div class="batch-title">üì¶ Batch Export</div>
                        <div class="batch-options">
                            <div class="batch-option">
                                <input type="checkbox" id="batchFeaturePng" checked>
                                <label for="batchFeaturePng">PNG 1280x800</label>
                            </div>
                            <div class="batch-option">
                                <input type="checkbox" id="batchFeatureJpg">
                                <label for="batchFeatureJpg">JPEG 1280x800</label>
                            </div>
                            <div class="batch-option">
                                <input type="checkbox" id="batchFeatureWebp">
                                <label for="batchFeatureWebp">WebP 1280x800</label>
                            </div>
                            <div class="batch-option">
                                <input type="checkbox" id="batchFeature1024">
                                <label for="batchFeature1024">PNG 1024x500</label>
                            </div>
                        </div>
                        <button class="btn" onclick="batchExport('feature-graphic-1280x800.svg', 'banner', 'Feature')">
                            üì¶ Batch Export Selected
                        </button>
                        <div class="progress-bar" id="progressFeature" style="display: none;">
                            <div class="progress-fill" id="progressFillFeature"></div>
                        </div>
                    </div>

                    <div id="statusFeature" class="status-message" style="display: none;"></div>
                    <div id="debugFeature" class="status-message debug-info" style="display: none;"></div>
                </div>
            </div>
        </div>

        <div class="asset-group">
            <div class="asset-title">üìù App Store Description</div>
            <p>Marketing-optimized description for app store submissions</p>
            <div>
                <button class="btn" onclick="downloadDescription()">
                    üì• Download Description Text
                </button>
            </div>
        </div>

        <div class="instructions">
            <h3>üöÄ Enhanced Features</h3>
            <ul>
                <li><strong>Custom Dimensions:</strong> Specify any width/height for your output images</li>
                <li><strong>Preview Before Export:</strong> See exactly how your image will look before downloading</li>
                <li><strong>Multiple Formats:</strong> Export as PNG, JPEG, WebP, ICO, or original SVG</li>
                <li><strong>Batch Export:</strong> Download multiple formats and sizes simultaneously</li>
                <li><strong>Quality Control:</strong> Adjust compression for optimal file sizes</li>
                <li><strong>Auto-Save Settings:</strong> Your preferences are remembered between sessions</li>
                <li><strong>Dynamic Icons:</strong> Icons rotate through different styles on each reload for visual variety</li>
                <li><strong>Refresh Button:</strong> Click the refresh button or press Ctrl+R to reload with new icon styles</li>
                <li><strong>Keyboard Shortcuts:</strong> Ctrl+1/2/3 for quick conversion, Ctrl+R to refresh, Esc to close preview</li>
                <li><strong>Debug Mode:</strong> Detailed diagnostics for troubleshooting issues</li>
                <li><strong>Smart Fallbacks:</strong> Professional placeholder generation when SVG files fail</li>
            </ul>

            <h4>üì± Format Recommendations</h4>
            <ul>
                <li><strong>PNG:</strong> Best for icons with transparency, app store requirements</li>
                <li><strong>JPEG:</strong> Smaller file sizes for photos/banners, no transparency</li>
                <li><strong>WebP:</strong> Modern format with excellent compression (check browser support)</li>
                <li><strong>ICO:</strong> Windows icon format for desktop applications</li>
                <li><strong>SVG:</strong> Vector format for web use, infinite scalability</li>
            </ul>

            <p><strong>üí° Pro Tips:</strong></p>
            <ul>
                <li>Use <strong>Preview & Convert</strong> to verify quality before downloading</li>
                <li>Try <strong>Batch Export</strong> to get multiple formats at once</li>
                <li>Use <strong>Custom Dimensions</strong> for platform-specific requirements</li>
                <li>Enable <strong>Debug Mode</strong> if you encounter conversion issues</li>
                <li>Fallback generators create professional placeholders with your app's branding</li>
            </ul>
        </div>
    </div>

    <!-- Preview Modal -->
    <div id="previewModal" class="preview-modal">
        <div class="preview-modal-content">
            <button class="close-modal" onclick="closePreviewModal()">√ó</button>
            <h3 id="previewTitle">Image Preview</h3>
            <div style="text-align: center; margin: 20px 0;">
                <img id="previewImage" alt="Preview">
            </div>
            <div id="previewInfo" style="margin: 15px 0; font-size: 14px; opacity: 0.8;"></div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn" id="confirmDownloadBtn">
                    üì• Confirm & Download
                </button>
                <button class="btn btn-outline" onclick="closePreviewModal()" style="background: rgba(255,255,255,0.1); margin-left: 10px;">
                    ‚ùå Cancel
                </button>
            </div>
        </div>
    </div>

    <canvas id="conversionCanvas"></canvas>
    <canvas id="fallbackCanvas"></canvas>
    <canvas id="previewCanvas"></canvas>

    <script>
        // Utility functions
        function showStatus(elementId, message, type) {
            const statusEl = document.getElementById(elementId);
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.className = `status-message status-${type}`;
                statusEl.style.display = 'block';
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 8000);
            }
        }

        function showDebug(elementId, info) {
            const debugEl = document.getElementById(elementId);
            if (debugEl) {
                debugEl.textContent = info;
                debugEl.style.display = 'block';
            }
        }

        // Global variables for preview functionality
        let currentPreviewData = null;
        let iconRotationIndex = 0;
        let iconStyles = [
            'modern', 'gradient', 'flat', 'material', 'ios', 'retro', 'neon', 'minimal'
        ];
        let currentIconStyle = 'modern';

        // Generate dynamic app icons with different styles
        function generateDynamicIcon(width, height, style = 'modern') {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = width;
            canvas.height = height;

            // Style-specific color schemes
            const colorSchemes = {
                modern: ['#667eea', '#764ba2', '#f093fb'],
                gradient: ['#FF6B6B', '#4ECDC4', '#45B7D1'],
                flat: ['#3498db', '#e74c3c', '#2ecc71'],
                material: ['#2196F3', '#FF5722', '#4CAF50'],
                ios: ['#007AFF', '#FF3B30', '#34C759'],
                retro: ['#FF6B35', '#F7931E', '#FFD23F'],
                neon: ['#FF0080', '#00FF80', '#8000FF'],
                minimal: ['#2C3E50', '#34495E', '#7F8C8D']
            };

            const colors = colorSchemes[style] || colorSchemes.modern;

            // Create gradient background
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, colors[0]);
            gradient.addColorStop(0.5, colors[1]);
            gradient.addColorStop(1, colors[2]);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Add style-specific patterns
            switch(style) {
                case 'modern':
                    drawModernPattern(ctx, width, height);
                    break;
                case 'gradient':
                    drawGradientPattern(ctx, width, height);
                    break;
                case 'flat':
                    drawFlatPattern(ctx, width, height);
                    break;
                case 'material':
                    drawMaterialPattern(ctx, width, height);
                    break;
                case 'ios':
                    drawIOSPattern(ctx, width, height);
                    break;
                case 'retro':
                    drawRetroPattern(ctx, width, height);
                    break;
                case 'neon':
                    drawNeonPattern(ctx, width, height);
                    break;
                case 'minimal':
                    drawMinimalPattern(ctx, width, height);
                    break;
            }

            return canvas.toDataURL('image/png');
        }

        // Pattern drawing functions for different styles
        function drawModernPattern(ctx, width, height) {
            // Modern phone with app grid
            const centerX = width / 2;
            const centerY = height / 2;
            const phoneWidth = width * 0.25;
            const phoneHeight = height * 0.45;

            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = width * 0.02;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(centerX - phoneWidth/2, centerY - phoneHeight/2, phoneWidth, phoneHeight);

            ctx.shadowColor = 'transparent';
            ctx.fillStyle = '#4A90E2';
            const margin = phoneWidth * 0.12;
            ctx.fillRect(centerX - phoneWidth/2 + margin, centerY - phoneHeight/2 + margin,
                        phoneWidth - margin * 2, phoneHeight - margin * 2.5);

            // App grid
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            const gridSize = phoneWidth * 0.06;
            const spacing = phoneWidth * 0.09;
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    ctx.globalAlpha = 0.5 + Math.random() * 0.5;
                    ctx.fillRect(centerX - spacing + col * spacing, centerY - spacing * 0.8 + row * spacing, gridSize, gridSize);
                }
            }
            ctx.globalAlpha = 1;
        }

        function drawGradientPattern(ctx, width, height) {
            // Colorful circles pattern
            for (let i = 0; i < 8; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const radius = Math.random() * width * 0.1 + width * 0.05;

                const circleGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                circleGradient.addColorStop(0, `rgba(255, 255, 255, ${0.3 + Math.random() * 0.4})`);
                circleGradient.addColorStop(1, `rgba(255, 255, 255, 0)`);

                ctx.fillStyle = circleGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawFlatPattern(ctx, width, height) {
            // Geometric shapes
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(width * 0.2, height * 0.2, width * 0.6, height * 0.1);
            ctx.fillRect(width * 0.3, height * 0.4, width * 0.4, height * 0.1);
            ctx.fillRect(width * 0.25, height * 0.6, width * 0.5, height * 0.1);

            // Central icon
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.arc(width/2, height/2, width * 0.08, 0, Math.PI * 2);
            ctx.fill();
        }

        // Load and display SVG previews with enhanced fallback
        function loadPreviews() {
            // Rotate to next icon style
            currentIconStyle = iconStyles[iconRotationIndex % iconStyles.length];
            iconRotationIndex++;

            loadPreviewWithFallback('icon512Preview', 'app-icon-512x512.svg', 512, 512, 'icon');
            loadPreviewWithFallback('icon114Preview', 'app-icon-114x114.svg', 114, 114, 'icon');
            loadPreviewWithFallback('featurePreview', 'feature-graphic-1280x800.svg', 1280, 800, 'banner');

            // Update info labels
            updateIconInfo();
        }

        // Additional pattern functions
        function drawMaterialPattern(ctx, width, height) {
            // Material design floating action button style
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = width * 0.03;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.arc(width/2, height/2, width * 0.15, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowColor = 'transparent';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = `${width * 0.1}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('üì±', width/2, height/2 + width * 0.03);
        }

        function drawIOSPattern(ctx, width, height) {
            // iOS-style rounded rectangle with gloss
            const centerX = width / 2;
            const centerY = height / 2;
            const rectWidth = width * 0.4;
            const rectHeight = height * 0.4;
            const radius = width * 0.05;

            // Main shape
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.roundRect(centerX - rectWidth/2, centerY - rectHeight/2, rectWidth, rectHeight, radius);
            ctx.fill();

            // Gloss effect
            const glossGradient = ctx.createLinearGradient(0, centerY - rectHeight/2, 0, centerY);
            glossGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
            glossGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = glossGradient;
            ctx.beginPath();
            ctx.roundRect(centerX - rectWidth/2, centerY - rectHeight/2, rectWidth, rectHeight/2, radius);
            ctx.fill();
        }

        function drawRetroPattern(ctx, width, height) {
            // Retro pixel-style pattern
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            const pixelSize = width * 0.05;
            for (let x = 0; x < width; x += pixelSize * 2) {
                for (let y = 0; y < height; y += pixelSize * 2) {
                    if (Math.random() > 0.7) {
                        ctx.fillRect(x, y, pixelSize, pixelSize);
                    }
                }
            }

            // Central retro icon
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(width/2 - width*0.08, height/2 - width*0.08, width*0.16, width*0.16);
        }

        function drawNeonPattern(ctx, width, height) {
            // Neon glow effect
            ctx.shadowColor = '#FF0080';
            ctx.shadowBlur = width * 0.05;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = width * 0.01;

            // Neon outline
            ctx.beginPath();
            ctx.arc(width/2, height/2, width * 0.12, 0, Math.PI * 2);
            ctx.stroke();

            ctx.shadowColor = '#00FF80';
            ctx.beginPath();
            ctx.arc(width/2, height/2, width * 0.08, 0, Math.PI * 2);
            ctx.stroke();
        }

        function drawMinimalPattern(ctx, width, height) {
            // Clean minimal design
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, width, height * 0.02);
            ctx.fillRect(0, height * 0.98, width, height * 0.02);

            // Simple centered element
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(width/2, height/2, width * 0.02, 0, Math.PI * 2);
            ctx.fill();
        }

        // Update icon info labels
        function updateIconInfo() {
            const styleName = currentIconStyle.charAt(0).toUpperCase() + currentIconStyle.slice(1);
            document.getElementById('icon512Info').textContent = `${styleName} Style`;
            document.getElementById('icon114Info').textContent = `${styleName} Style`;
            document.getElementById('featureInfo').textContent = `${styleName} Banner`;
            document.getElementById('currentStyleIndicator').textContent = `Current Style: ${styleName}`;
        }

        // Reload converter with new icons
        function reloadConverter() {
            const reloadIcon = document.getElementById('reloadIcon');

            // Animate reload button
            reloadIcon.style.transform = 'rotate(360deg)';
            setTimeout(() => {
                reloadIcon.style.transform = 'rotate(0deg)';
            }, 600);

            // Add changing animation to all dynamic icons
            const dynamicIcons = document.querySelectorAll('.dynamic-icon');
            dynamicIcons.forEach(icon => {
                icon.classList.add('changing');
                setTimeout(() => {
                    icon.classList.remove('changing');
                }, 600);
            });

            // Reload previews with new style
            setTimeout(() => {
                loadPreviews();
            }, 300);

            // Show reload notification with style info
            setTimeout(() => {
                const styleName = currentIconStyle.charAt(0).toUpperCase() + currentIconStyle.slice(1);
                showStatus('status512', `üé® Refreshed with ${styleName} style icons! (${iconStyles.length} styles available)`, 'success');
            }, 400);
        }

        // Auto-rotate icons on page load with a slight delay for better UX
        function initializeDynamicIcons() {
            // Start with a random style
            iconRotationIndex = Math.floor(Math.random() * iconStyles.length);
            currentIconStyle = iconStyles[iconRotationIndex];

            // Load initial previews
            setTimeout(() => {
                loadPreviews();
            }, 500);
        }

        // Get custom dimensions from input fields
        function getCustomDimensions(suffix) {
            const width = parseInt(document.getElementById(`customWidth${suffix}`).value) || 512;
            const height = parseInt(document.getElementById(`customHeight${suffix}`).value) || 512;
            return { width, height };
        }

        // Get selected format
        function getSelectedFormat(suffix) {
            const radios = document.getElementsByName(`format${suffix}`);
            for (const radio of radios) {
                if (radio.checked) return radio.value;
            }
            return 'png';
        }

        // Preview and convert function
        function previewAndConvert(svgFile, type, suffix) {
            const { width, height } = getCustomDimensions(suffix);
            const format = getSelectedFormat(suffix);
            const quality = parseFloat(document.getElementById(`quality${suffix}`).value);

            showStatus(`status${suffix}`, 'Generating preview...', 'info');

            // Generate preview
            generateImagePreview(svgFile, width, height, type, format, quality, (previewDataUrl, fileSize) => {
                showPreviewModal(previewDataUrl, width, height, format, fileSize, () => {
                    // Confirm download callback
                    downloadFromDataUrl(previewDataUrl, `${svgFile.replace('.svg', '')}-${width}x${height}.${format === 'jpeg' ? 'jpg' : format}`);
                    closePreviewModal();
                    showStatus(`status${suffix}`, 'Download completed!', 'success');
                });
                showStatus(`status${suffix}`, 'Preview ready - click to download', 'success');
            }, (error) => {
                showStatus(`status${suffix}`, `Preview failed: ${error}`, 'error');
            });
        }

        // Generate image preview with multiple format support
        function generateImagePreview(svgFile, width, height, type, format, quality, successCallback, errorCallback) {
            const canvas = document.getElementById('previewCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = width;
            canvas.height = height;

            // Try to load SVG first
            fetch(svgFile)
                .then(response => {
                    if (!response.ok) throw new Error(`SVG not found: ${response.status}`);
                    return response.text();
                })
                .then(svgText => {
                    const img = new Image();
                    img.onload = function() {
                        try {
                            ctx.clearRect(0, 0, width, height);

                            // Handle different formats
                            if (format === 'jpeg') {
                                // Fill white background for JPEG
                                ctx.fillStyle = 'white';
                                ctx.fillRect(0, 0, width, height);
                            }

                            ctx.drawImage(img, 0, 0, width, height);

                            // Convert to appropriate format
                            let mimeType = `image/${format}`;
                            if (format === 'ico') {
                                mimeType = 'image/png'; // ICO will be handled specially
                            } else if (format === 'svg') {
                                // Return original SVG
                                successCallback(`data:image/svg+xml;base64,${btoa(svgText)}`, svgText.length);
                                return;
                            }

                            const dataUrl = canvas.toDataURL(mimeType, quality);
                            const fileSize = Math.round(dataUrl.length * 0.75); // Approximate file size
                            successCallback(dataUrl, fileSize);

                        } catch (error) {
                            errorCallback(`Canvas rendering failed: ${error.message}`);
                        }
                    };

                    img.onerror = function() {
                        errorCallback('SVG image loading failed');
                    };

                    const blob = new Blob([svgText], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    img.src = url;
                    setTimeout(() => URL.revokeObjectURL(url), 2000);
                })
                .catch(error => {
                    // Generate fallback if SVG fails
                    console.log('SVG failed, generating fallback preview');
                    generateFallbackImage(width, height, type, (fallbackDataUrl) => {
                        if (format === 'jpeg') {
                            // Convert fallback to JPEG
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCanvas.width = width;
                            tempCanvas.height = height;

                            const fallbackImg = new Image();
                            fallbackImg.onload = function() {
                                tempCtx.fillStyle = 'white';
                                tempCtx.fillRect(0, 0, width, height);
                                tempCtx.drawImage(fallbackImg, 0, 0, width, height);
                                const jpegDataUrl = tempCanvas.toDataURL('image/jpeg', quality);
                                const fileSize = Math.round(jpegDataUrl.length * 0.75);
                                successCallback(jpegDataUrl, fileSize);
                            };
                            fallbackImg.src = fallbackDataUrl;
                        } else if (format === 'webp') {
                            // Convert fallback to WebP
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCanvas.width = width;
                            tempCanvas.height = height;

                            const fallbackImg = new Image();
                            fallbackImg.onload = function() {
                                tempCtx.drawImage(fallbackImg, 0, 0, width, height);
                                try {
                                    const webpDataUrl = tempCanvas.toDataURL('image/webp', quality);
                                    const fileSize = Math.round(webpDataUrl.length * 0.75);
                                    successCallback(webpDataUrl, fileSize);
                                } catch (e) {
                                    // WebP not supported, fallback to PNG
                                    const pngDataUrl = tempCanvas.toDataURL('image/png', quality);
                                    const fileSize = Math.round(pngDataUrl.length * 0.75);
                                    successCallback(pngDataUrl, fileSize);
                                }
                            };
                            fallbackImg.src = fallbackDataUrl;
                        } else {
                            const fileSize = Math.round(fallbackDataUrl.length * 0.75);
                            successCallback(fallbackDataUrl, fileSize);
                        }
                    });
                });
        }

        // Show preview modal
        function showPreviewModal(dataUrl, width, height, format, fileSize, confirmCallback) {
            const modal = document.getElementById('previewModal');
            const img = document.getElementById('previewImage');
            const title = document.getElementById('previewTitle');
            const info = document.getElementById('previewInfo');
            const confirmBtn = document.getElementById('confirmDownloadBtn');

            title.textContent = `Preview: ${width}√ó${height} ${format.toUpperCase()}`;
            img.src = dataUrl;
            info.textContent = `File size: ~${(fileSize/1024).toFixed(1)}KB | Format: ${format.toUpperCase()} | Dimensions: ${width}√ó${height}px`;

            // Store current preview data
            currentPreviewData = { dataUrl, width, height, format, fileSize, confirmCallback };

            // Set up confirm button
            confirmBtn.onclick = confirmCallback;

            modal.style.display = 'flex';
        }

        // Close preview modal
        function closePreviewModal() {
            document.getElementById('previewModal').style.display = 'none';
            currentPreviewData = null;
        }

        // Download from data URL
        function downloadFromDataUrl(dataUrl, filename) {
            const a = document.createElement('a');
            a.href = dataUrl;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // Generate custom fallback
        function generateCustomFallback(type, suffix) {
            const { width, height } = getCustomDimensions(suffix);
            const format = getSelectedFormat(suffix);
            const quality = parseFloat(document.getElementById(`quality${suffix}`).value);

            showStatus(`status${suffix}`, 'Generating custom fallback...', 'info');

            generateFallbackImage(width, height, type, (dataUrl) => {
                // Convert to selected format if needed
                if (format !== 'png') {
                    convertDataUrlFormat(dataUrl, format, quality, (convertedDataUrl) => {
                        const filename = `fallback-${type}-${width}x${height}.${format === 'jpeg' ? 'jpg' : format}`;
                        const fileSize = Math.round(convertedDataUrl.length * 0.75);
                        showPreviewModal(convertedDataUrl, width, height, format, fileSize, () => {
                            downloadFromDataUrl(convertedDataUrl, filename);
                            closePreviewModal();
                            showStatus(`status${suffix}`, 'Fallback downloaded!', 'success');
                        });
                    });
                } else {
                    const filename = `fallback-${type}-${width}x${height}.png`;
                    const fileSize = Math.round(dataUrl.length * 0.75);
                    showPreviewModal(dataUrl, width, height, format, fileSize, () => {
                        downloadFromDataUrl(dataUrl, filename);
                        closePreviewModal();
                        showStatus(`status${suffix}`, 'Fallback downloaded!', 'success');
                    });
                }
            });
        }

        // Convert data URL to different format
        function convertDataUrlFormat(dataUrl, targetFormat, quality, callback) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();

            img.onload = function() {
                canvas.width = img.width;
                canvas.height = img.height;

                if (targetFormat === 'jpeg') {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                ctx.drawImage(img, 0, 0);

                try {
                    let mimeType = `image/${targetFormat}`;
                    if (targetFormat === 'ico') mimeType = 'image/png';

                    const convertedDataUrl = canvas.toDataURL(mimeType, quality);
                    callback(convertedDataUrl);
                } catch (error) {
                    console.error('Format conversion error:', error);
                    callback(dataUrl); // Return original if conversion fails
                }
            };

            img.src = dataUrl;
        }

        // Batch export functionality
        function batchExport(svgFile, type, suffix) {
            const progressBar = document.getElementById(`progress${suffix}`);
            const progressFill = document.getElementById(`progressFill${suffix}`);
            const statusId = `status${suffix}`;

            // Get selected batch options
            const batchOptions = [];
            const checkboxes = document.querySelectorAll(`input[id^="batch${suffix}"]:checked`);

            checkboxes.forEach(checkbox => {
                const id = checkbox.id;
                let width, height, format;

                if (id.includes('png')) {
                    format = 'png';
                    if (id.includes('512')) { width = 512; height = 512; }
                    else if (id.includes('114')) { width = 114; height = 114; }
                    else if (id.includes('256')) { width = 256; height = 256; }
                    else if (id.includes('1024')) { width = 1024; height = 500; }
                    else { width = 1280; height = 800; }
                } else if (id.includes('jpg')) {
                    format = 'jpeg';
                    if (id.includes('512')) { width = 512; height = 512; }
                    else if (id.includes('114')) { width = 114; height = 114; }
                    else { width = 1280; height = 800; }
                } else if (id.includes('webp')) {
                    format = 'webp';
                    if (id.includes('512')) { width = 512; height = 512; }
                    else if (id.includes('114')) { width = 114; height = 114; }
                    else { width = 1280; height = 800; }
                } else if (id.includes('ico')) {
                    format = 'ico';
                    width = 114; height = 114;
                }

                batchOptions.push({ width, height, format, filename: `${type}-${width}x${height}.${format === 'jpeg' ? 'jpg' : format}` });
            });

            if (batchOptions.length === 0) {
                showStatus(statusId, 'No batch options selected', 'error');
                return;
            }

            showStatus(statusId, `Starting batch export of ${batchOptions.length} files...`, 'info');
            progressBar.style.display = 'block';
            progressFill.style.width = '0%';

            let completed = 0;
            const quality = parseFloat(document.getElementById(`quality${suffix}`).value);

            // Process each option
            batchOptions.forEach((option, index) => {
                setTimeout(() => {
                    generateImagePreview(svgFile, option.width, option.height, type, option.format, quality,
                        (dataUrl, fileSize) => {
                            downloadFromDataUrl(dataUrl, option.filename);
                            completed++;
                            const progress = (completed / batchOptions.length) * 100;
                            progressFill.style.width = `${progress}%`;

                            if (completed === batchOptions.length) {
                                showStatus(statusId, `Batch export completed! ${completed} files downloaded.`, 'success');
                                setTimeout(() => {
                                    progressBar.style.display = 'none';
                                }, 2000);
                            }
                        },
                        (error) => {
                            console.error(`Batch item ${index} failed:`, error);
                            completed++;
                            const progress = (completed / batchOptions.length) * 100;
                            progressFill.style.width = `${progress}%`;
                        }
                    );
                }, index * 500); // Stagger exports to prevent browser overload
            });
        }

        function loadPreviewWithFallback(previewId, svgFile, width, height, type) {
            const img = document.getElementById(previewId);

            fetch(svgFile)
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    return response.text();
                })
                .then(svgText => {
                    const blob = new Blob([svgText], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(blob);

                    const testImg = new Image();
                    testImg.onload = () => {
                        img.src = url;
                        URL.revokeObjectURL(url);
                    };
                    testImg.onerror = () => {
                        URL.revokeObjectURL(url);
                        // Use dynamic icon generation instead of static fallback
                        const dynamicIcon = generateDynamicIcon(width, height, currentIconStyle);
                        img.src = dynamicIcon;
                    };
                    testImg.src = url;
                })
                .catch(error => {
                    console.log(`SVG ${svgFile} not available, generating dynamic ${currentIconStyle} preview`);
                    // Use dynamic icon generation for better visual variety
                    const dynamicIcon = generateDynamicIcon(width, height, currentIconStyle);
                    img.src = dynamicIcon;
                });
        }

        // Enhanced SVG to PNG conversion with better error handling
        function convertAndDownload(svgFile, width, height, outputName, qualitySelectId) {
            const statusId = getStatusId(outputName);
            const quality = qualitySelectId ? parseFloat(document.getElementById(qualitySelectId).value) : 1.0;

            showStatus(statusId, 'Starting conversion...', 'info');

            const canvas = document.getElementById('conversionCanvas');
            const ctx = canvas.getContext('2d');

            // Enhanced canvas setup for better quality
            const scale = Math.min(2, Math.max(1, 1024 / Math.max(width, height)));
            canvas.width = width * scale;
            canvas.height = height * scale;
            ctx.scale(scale, scale);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            const img = new Image();
            img.crossOrigin = 'anonymous';

            const timeout = setTimeout(() => {
                showStatus(statusId, 'Conversion timeout. Try fallback generator.', 'error');
            }, 10000);

            img.onload = function() {
                clearTimeout(timeout);
                try {
                    ctx.clearRect(0, 0, width, height);
                    ctx.drawImage(img, 0, 0, width, height);

                    canvas.toBlob(function(blob) {
                        if (blob && blob.size > 0) {
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = outputName;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            showStatus(statusId, `PNG downloaded successfully! (${(blob.size/1024).toFixed(1)}KB)`, 'success');
                        } else {
                            throw new Error('Empty blob generated');
                        }
                    }, 'image/png', quality);
                } catch (error) {
                    console.error('Canvas conversion error:', error);
                    showStatus(statusId, `Conversion failed: ${error.message}`, 'error');
                }
            };

            img.onerror = function(e) {
                clearTimeout(timeout);
                console.error('Image load error:', e);
                showStatus(statusId, 'Image rendering failed. Try fallback generator.', 'error');
            };

            // Enhanced SVG loading
            fetch(svgFile)
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    return response.text();
                })
                .then(svgText => {
                    showStatus(statusId, 'SVG loaded, converting...', 'info');

                    // Clean SVG for better compatibility
                    const cleanedSvg = svgText
                        .replace(/xmlns:xlink="[^"]*"/g, '')
                        .replace(/xlink:/g, '')
                        .replace(/<!--[\s\S]*?-->/g, ''); // Remove comments

                    const svgBlob = new Blob([cleanedSvg], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(svgBlob);
                    img.src = url;

                    setTimeout(() => URL.revokeObjectURL(url), 2000);
                })
                .catch(error => {
                    clearTimeout(timeout);
                    console.error('Fetch error:', error);
                    showStatus(statusId, `File not found: ${svgFile}. Use fallback generator.`, 'error');
                });
        }

        // Special function for feature graphic conversion with enhanced handling
        function convertFeatureGraphic() {
            const quality = parseFloat(document.getElementById('qualityFeature').value);
            const scale = parseFloat(document.getElementById('scaleFeature').value);
            const finalWidth = Math.round(1280 * scale);
            const finalHeight = Math.round(800 * scale);
            const outputName = `feature-graphic-${finalWidth}x${finalHeight}.png`;

            showStatus('statusFeature', 'Processing large feature graphic...', 'info');

            const canvas = document.getElementById('conversionCanvas');
            const ctx = canvas.getContext('2d');

            // Special handling for large images
            canvas.width = finalWidth;
            canvas.height = finalHeight;
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            const img = new Image();
            img.crossOrigin = 'anonymous';

            const timeout = setTimeout(() => {
                showStatus('statusFeature', 'Large image conversion timeout. Trying fallback...', 'error');
                generateFallbackAndDownload(finalWidth, finalHeight, `${outputName}-fallback`, 'banner');
            }, 15000); // Longer timeout for large images

            img.onload = function() {
                clearTimeout(timeout);
                try {
                    showStatus('statusFeature', 'Rendering large image...', 'info');

                    ctx.clearRect(0, 0, finalWidth, finalHeight);
                    ctx.drawImage(img, 0, 0, finalWidth, finalHeight);

                    // Use requestAnimationFrame for better performance
                    requestAnimationFrame(() => {
                        canvas.toBlob(function(blob) {
                            if (blob && blob.size > 0) {
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = outputName;
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                                URL.revokeObjectURL(url);
                                showStatus('statusFeature', `Feature graphic downloaded! (${(blob.size/1024/1024).toFixed(2)}MB)`, 'success');
                            } else {
                                throw new Error('Failed to generate blob for large image');
                            }
                        }, 'image/png', quality);
                    });
                } catch (error) {
                    clearTimeout(timeout);
                    console.error('Feature graphic conversion error:', error);
                    showStatus('statusFeature', `Large image conversion failed: ${error.message}`, 'error');
                }
            };

            img.onerror = function(e) {
                clearTimeout(timeout);
                console.error('Feature graphic load error:', e);
                showStatus('statusFeature', 'Feature graphic failed to load. Using fallback...', 'error');
                generateFallbackAndDownload(finalWidth, finalHeight, `${outputName}-fallback`, 'banner');
            };

            // Load feature graphic with enhanced error handling
            fetch('feature-graphic-1280x800.svg')
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    return response.text();
                })
                .then(svgText => {
                    showStatus('statusFeature', 'Feature graphic loaded, processing...', 'info');

                    // Enhanced SVG cleaning for large graphics
                    const cleanedSvg = svgText
                        .replace(/xmlns:xlink="[^"]*"/g, '')
                        .replace(/xlink:/g, '')
                        .replace(/<!--[\s\S]*?-->/g, '')
                        .replace(/\s+/g, ' ') // Compress whitespace
                        .trim();

                    const svgBlob = new Blob([cleanedSvg], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(svgBlob);
                    img.src = url;

                    setTimeout(() => URL.revokeObjectURL(url), 3000);
                })
                .catch(error => {
                    clearTimeout(timeout);
                    console.error('Feature graphic fetch error:', error);
                    showStatus('statusFeature', 'Feature graphic not found. Generating fallback...', 'error');
                    generateFallbackAndDownload(finalWidth, finalHeight, `${outputName}-fallback`, 'banner');
                });
        }

        // Generate fallback placeholder images
        function generateFallbackImage(width, height, type, callback) {
            const canvas = document.getElementById('fallbackCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = width;
            canvas.height = height;

            // Create app-themed gradient background
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, '#667eea');
            gradient.addColorStop(0.5, '#764ba2');
            gradient.addColorStop(1, '#f093fb');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Add subtle pattern
            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            for (let x = 0; x < width; x += 40) {
                for (let y = 0; y < height; y += 40) {
                    ctx.beginPath();
                    ctx.arc(x + 20, y + 20, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            if (type === 'icon') {
                generateIconFallback(ctx, width, height);
            } else if (type === 'banner') {
                generateBannerFallback(ctx, width, height);
            }

            callback(canvas.toDataURL('image/png', 1.0));
        }

        function generateIconFallback(ctx, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const phoneWidth = width * 0.25;
            const phoneHeight = height * 0.45;

            // Draw phone with shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = width * 0.02;
            ctx.shadowOffsetY = width * 0.01;

            // Phone body
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(centerX - phoneWidth/2, centerY - phoneHeight/2, phoneWidth, phoneHeight);

            // Screen
            ctx.shadowColor = 'transparent';
            ctx.fillStyle = '#4A90E2';
            const screenMargin = phoneWidth * 0.12;
            ctx.fillRect(
                centerX - phoneWidth/2 + screenMargin,
                centerY - phoneHeight/2 + screenMargin,
                phoneWidth - screenMargin * 2,
                phoneHeight - screenMargin * 2.5
            );

            // App grid on screen
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            const gridSize = phoneWidth * 0.06;
            const gridSpacing = phoneWidth * 0.09;
            const startX = centerX - gridSpacing;
            const startY = centerY - gridSpacing * 0.8;

            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const alpha = 0.5 + (Math.random() * 0.5); // Random opacity
                    ctx.globalAlpha = alpha;
                    ctx.fillRect(
                        startX + col * gridSpacing,
                        startY + row * gridSpacing,
                        gridSize,
                        gridSize
                    );
                }
            }
            ctx.globalAlpha = 1;

            // Home button
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(centerX, centerY + phoneHeight/2 - screenMargin, phoneWidth * 0.04, 0, Math.PI * 2);
            ctx.fill();

            // Text
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = width * 0.01;
            ctx.fillStyle = 'white';
            ctx.font = `bold ${width * 0.08}px Inter, Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText('CAG', centerX, centerY + phoneHeight/2 + width * 0.12);

            // Reset shadow
            ctx.shadowColor = 'transparent';
        }

        function generateBannerFallback(ctx, width, height) {
            // Draw main title
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = height * 0.01;
            ctx.fillStyle = 'white';
            ctx.font = `bold ${height * 0.09}px Inter, Arial, sans-serif`;
            ctx.textAlign = 'left';
            ctx.fillText('CORDOVA', width * 0.06, height * 0.25);
            ctx.fillText('APP GENERATOR', width * 0.06, height * 0.38);

            // Subtitle
            ctx.font = `600 ${height * 0.04}px Inter, Arial, sans-serif`;
            ctx.fillText('Create Multiple Mobile Apps Instantly', width * 0.06, height * 0.48);

            // Feature bullets
            ctx.font = `500 ${height * 0.025}px Inter, Arial, sans-serif`;
            const features = [
                'üöÄ Generate up to 10 apps simultaneously',
                'üé® Professional templates & themes',
                'üåê Automatic GitHub integration',
                'üì± Production-ready Cordova projects'
            ];

            features.forEach((feature, index) => {
                ctx.fillText(feature, width * 0.06, height * 0.55 + index * height * 0.05);
            });

            // Draw phones on the right with shadows
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = height * 0.02;

            const phoneX = width * 0.75;
            const phoneY = height * 0.5;
            const phoneWidth = width * 0.06;
            const phoneHeight = height * 0.25;

            // Main phone
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(phoneX - phoneWidth/2, phoneY - phoneHeight/2, phoneWidth, phoneHeight);

            ctx.shadowColor = 'transparent';
            ctx.fillStyle = '#4A90E2';
            ctx.fillRect(
                phoneX - phoneWidth/2 + phoneWidth * 0.1,
                phoneY - phoneHeight/2 + phoneHeight * 0.1,
                phoneWidth * 0.8,
                phoneHeight * 0.7
            );

            // Side phones with rotation
            ctx.save();
            ctx.translate(phoneX - width * 0.08, phoneY - height * 0.12);
            ctx.rotate(-0.15);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillRect(-phoneWidth/3, -phoneHeight/3, phoneWidth * 0.6, phoneHeight * 0.6);
            ctx.fillStyle = '#764ba2';
            ctx.fillRect(-phoneWidth/4, -phoneHeight/4, phoneWidth * 0.4, phoneHeight * 0.4);
            ctx.restore();

            ctx.save();
            ctx.translate(phoneX + width * 0.08, phoneY + height * 0.08);
            ctx.rotate(0.1);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillRect(-phoneWidth/3, -phoneHeight/3, phoneWidth * 0.6, phoneHeight * 0.6);
            ctx.fillStyle = '#f093fb';
            ctx.fillRect(-phoneWidth/4, -phoneHeight/4, phoneWidth * 0.4, phoneHeight * 0.4);
            ctx.restore();

            // Bottom tagline
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = `600 ${height * 0.025}px Inter, Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText('Professional Mobile App Development Made Simple', width/2, height * 0.85);
        }

        // Generate and download fallback image
        function generateFallbackAndDownload(width, height, outputName, type) {
            const statusId = getStatusId(outputName);
            showStatus(statusId, 'Generating fallback image...', 'info');

            generateFallbackImage(width, height, type, (dataUrl) => {
                fetch(dataUrl)
                    .then(res => res.blob())
                    .then(blob => {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = outputName;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        showStatus(statusId, `Fallback image downloaded! (${(blob.size/1024).toFixed(1)}KB)`, 'success');
                    })
                    .catch(error => {
                        console.error('Fallback download error:', error);
                        showStatus(statusId, 'Fallback generation failed.', 'error');
                    });
            });
        }

        // Debug function to analyze SVG files
        function debugConversion(svgFile, debugElementId) {
            showStatus(debugElementId.replace('debug', 'status'), 'Running diagnostics...', 'info');

            let debugInfo = `=== SVG CONVERSION DIAGNOSTICS ===\n`;
            debugInfo += `File: ${svgFile}\n`;
            debugInfo += `Timestamp: ${new Date().toISOString()}\n\n`;

            fetch(svgFile)
                .then(response => {
                    debugInfo += `HTTP Status: ${response.status} ${response.statusText}\n`;
                    debugInfo += `Content-Type: ${response.headers.get('content-type')}\n`;
                    debugInfo += `Content-Length: ${response.headers.get('content-length') || 'unknown'}\n\n`;

                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    return response.text();
                })
                .then(svgText => {
                    debugInfo += `SVG Length: ${svgText.length} characters\n`;
                    debugInfo += `Has viewBox: ${svgText.includes('viewBox') ? 'Yes' : 'No'}\n`;
                    debugInfo += `Has width/height: ${svgText.includes('width=') && svgText.includes('height=') ? 'Yes' : 'No'}\n`;
                    debugInfo += `Has gradients: ${svgText.includes('linearGradient') ? 'Yes' : 'No'}\n`;
                    debugInfo += `Has filters: ${svgText.includes('<filter') ? 'Yes' : 'No'}\n`;
                    debugInfo += `Has patterns: ${svgText.includes('<pattern') ? 'Yes' : 'No'}\n`;
                    debugInfo += `Has text elements: ${svgText.includes('<text') ? 'Yes' : 'No'}\n\n`;

                    // Test image loading
                    const img = new Image();
                    const testStart = performance.now();

                    img.onload = function() {
                        const loadTime = performance.now() - testStart;
                        debugInfo += `Image Load: SUCCESS (${loadTime.toFixed(2)}ms)\n`;
                        debugInfo += `Natural Size: ${img.naturalWidth}x${img.naturalHeight}\n`;
                        debugInfo += `\n=== RECOMMENDATION ===\n`;
                        debugInfo += `‚úÖ SVG appears to be valid and loadable\n`;
                        debugInfo += `‚úÖ Try the regular conversion button\n`;
                        showDebug(debugElementId, debugInfo);
                    };

                    img.onerror = function(e) {
                        const loadTime = performance.now() - testStart;
                        debugInfo += `Image Load: FAILED (${loadTime.toFixed(2)}ms)\n`;
                        debugInfo += `Error: ${e.type || 'Unknown error'}\n`;
                        debugInfo += `\n=== RECOMMENDATION ===\n`;
                        debugInfo += `‚ùå SVG cannot be rendered as image\n`;
                        debugInfo += `üé≤ Use the fallback generator instead\n`;
                        showDebug(debugElementId, debugInfo);
                    };

                    const blob = new Blob([svgText], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    img.src = url;
                    setTimeout(() => URL.revokeObjectURL(url), 2000);
                })
                .catch(error => {
                    debugInfo += `Fetch Error: ${error.message}\n`;
                    debugInfo += `\n=== RECOMMENDATION ===\n`;
                    debugInfo += `‚ùå SVG file not accessible\n`;
                    debugInfo += `üé≤ Use the fallback generator\n`;
                    showDebug(debugElementId, debugInfo);
                });
        }

        // Download app store description with fallback
        function downloadDescription() {
            fetch('app-store-description.md')
                .then(response => {
                    if (!response.ok) throw new Error('Description file not found');
                    return response.text();
                })
                .then(text => {
                    const blob = new Blob([text], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'app-store-description.txt';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                })
                .catch(error => {
                    console.error('Error loading description:', error);
                    // Generate comprehensive fallback description
                    const fallbackText = `Cordova App Generator - Create Multiple Mobile Apps Instantly

üöÄ TRANSFORM YOUR IDEAS INTO PROFESSIONAL MOBILE APPLICATIONS

The Cordova App Generator is the ultimate development tool for creating multiple professional mobile applications simultaneously. Whether you're a developer, entrepreneur, or business owner, our powerful web-based platform streamlines the entire mobile app creation process.

‚ú® KEY FEATURES:
‚Ä¢ Generate up to 10 diverse mobile apps in a single session
‚Ä¢ Professional templates for Weather, Productivity, Utilities, Education, Health & Fitness, Finance, Entertainment, and Lifestyle
‚Ä¢ Automatic GitHub integration and deployment
‚Ä¢ Production-ready Cordova projects with modern HTML5/CSS3/JavaScript
‚Ä¢ No coding required - intuitive web interface
‚Ä¢ Cross-platform compatibility (Android & iOS)
‚Ä¢ Built-in plugin ecosystem with 15+ essential Cordova plugins

üéØ PERFECT FOR:
‚Ä¢ Developers looking to rapidly prototype multiple app concepts
‚Ä¢ Entrepreneurs wanting to test various app ideas quickly
‚Ä¢ Businesses needing multiple utility apps for different departments
‚Ä¢ Students learning mobile app development
‚Ä¢ Agencies creating apps for multiple clients

üíº PROFESSIONAL OUTPUT:
‚Ä¢ Complete Cordova project structure with proper directory layout
‚Ä¢ Modern, responsive code optimized for mobile devices
‚Ä¢ Comprehensive documentation with build instructions
‚Ä¢ MIT license included for commercial use
‚Ä¢ Ready for third-party build services (Codemagic, PhoneGap Build)

Download now and start creating professional mobile apps in minutes, not months!

Keywords: mobile app development, Cordova, PhoneGap, app generator, cross-platform, Android, iOS, rapid prototyping`;

                    const blob = new Blob([fallbackText], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'app-store-description-fallback.txt';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
        }

        function getStatusId(outputName) {
            if (outputName.includes('512x512') || outputName.includes('512')) return 'status512';
            if (outputName.includes('114x114') || outputName.includes('114')) return 'status114';
            if (outputName.includes('1280x800') || outputName.includes('feature') || outputName.includes('banner')) return 'statusFeature';
            return 'status512';
        }

        // Enhanced utility functions
        function getStatusId(outputName) {
            if (outputName.includes('512x512') || outputName.includes('512')) return 'status512';
            if (outputName.includes('114x114') || outputName.includes('114')) return 'status114';
            if (outputName.includes('1280x800') || outputName.includes('feature') || outputName.includes('Feature') || outputName.includes('banner')) return 'statusFeature';
            return 'status512';
        }

        // Keyboard shortcuts
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key) {
                        case '1':
                            e.preventDefault();
                            previewAndConvert('app-icon-512x512.svg', 'icon', '512');
                            break;
                        case '2':
                            e.preventDefault();
                            previewAndConvert('app-icon-114x114.svg', 'icon', '114');
                            break;
                        case '3':
                            e.preventDefault();
                            previewAndConvert('feature-graphic-1280x800.svg', 'banner', 'Feature');
                            break;
                        case 'r':
                        case 'R':
                            e.preventDefault();
                            reloadConverter();
                            break;
                        case 'Escape':
                            e.preventDefault();
                            closePreviewModal();
                            break;
                    }
                } else if (e.key === 'F5') {
                    e.preventDefault();
                    reloadConverter();
                }
            });
        }

        // Auto-save settings to localStorage
        function saveSettings() {
            const settings = {
                customWidth512: document.getElementById('customWidth512').value,
                customHeight512: document.getElementById('customHeight512').value,
                customWidth114: document.getElementById('customWidth114').value,
                customHeight114: document.getElementById('customHeight114').value,
                customWidthFeature: document.getElementById('customWidthFeature').value,
                customHeightFeature: document.getElementById('customHeightFeature').value,
                quality512: document.getElementById('quality512').value,
                quality114: document.getElementById('quality114').value,
                qualityFeature: document.getElementById('qualityFeature').value,
                format512: getSelectedFormat('512'),
                format114: getSelectedFormat('114'),
                formatFeature: getSelectedFormat('Feature')
            };
            localStorage.setItem('converterSettings', JSON.stringify(settings));
        }

        // Load settings from localStorage
        function loadSettings() {
            try {
                const settings = JSON.parse(localStorage.getItem('converterSettings') || '{}');

                Object.keys(settings).forEach(key => {
                    const element = document.getElementById(key);
                    if (element) {
                        if (element.type === 'radio') {
                            if (element.value === settings[key]) {
                                element.checked = true;
                            }
                        } else {
                            element.value = settings[key];
                        }
                    }
                });
            } catch (error) {
                console.log('No saved settings found');
            }
        }

        // Auto-save on input change
        function setupAutoSave() {
            const inputs = document.querySelectorAll('input, select');
            inputs.forEach(input => {
                input.addEventListener('change', saveSettings);
            });
        }

        // Load previews when page loads
        window.addEventListener('load', function() {
            console.log('Enhanced converter with dynamic icons loaded');
            loadSettings();
            setupKeyboardShortcuts();
            setupAutoSave();
            initializeDynamicIcons();
        });

        // Add error handling for the entire page
        window.addEventListener('error', function(e) {
            console.error('Global error:', e.error);
        });

        // Close modal on outside click
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('previewModal');
            if (e.target === modal) {
                closePreviewModal();
            }
        });
    </script>
</body>
</html>
